#!/usr/bin/env bash
set -euo pipefail

GGIT_PROJECT="${GGIT_PROJECT:-}"
GGIT_LOCATION="${GGIT_LOCATION:-europe-west8}"
GGIT_MODEL_ID="${GGIT_MODEL_ID:-gemini-2.5-flash-lite}"

if [ -z "$GGIT_PROJECT" ]; then
  echo "❌ Error: GGIT_PROJECT environment variable is not set."
  echo "   Please set it to your Google Cloud Project ID."
  echo "   Example: export GGIT_PROJECT=\"your-gcp-project\""
  exit 1
fi

TEMP_DIFF=$(mktemp)
TEMP_PROMPT=$(mktemp)
TEMP_API_RESPONSE_BODY=$(mktemp)

cleanup() {
  rm -f "$TEMP_DIFF" "$TEMP_PROMPT" "$TEMP_API_RESPONSE_BODY"
}
trap cleanup EXIT

DEBUG_MODE=false
FORWARD_ARGS=()
for arg in "$@"; do
  case "$arg" in
    --debug)
      DEBUG_MODE=true
      ;;
    *)
      FORWARD_ARGS+=("$arg")
      ;;
  esac
done

git diff --cached > "$TEMP_DIFF"
if [ ! -s "$TEMP_DIFF" ]; then
  echo "ℹ️ No staged changes to commit."
  exit 0
fi

FILES_CHANGED=$(git diff --cached --name-only)

# --- MODIFICHE INIZIANO QUI ---

if git rev-parse --verify HEAD &>/dev/null; then
  # Ci sono commit, HEAD è valido
  BRANCH_NAME=$(git rev-parse --abbrev-ref HEAD)
  COMMIT_HISTORY=$(git log -n 10 --pretty=format:"%s")
else
  # Nessun commit ancora (es. primo commit del repo), HEAD è "unborn"
  # git symbolic-ref --short HEAD ottiene il nome del ramo non ancora nato (es. main o master)
  # Aggiungiamo un fallback a "main" se symbolic-ref dovesse fallire per qualche motivo imprevisto.
  BRANCH_NAME=$(git symbolic-ref --short HEAD 2>/dev/null || echo "main")
  COMMIT_HISTORY="(no previous commits)"
fi

TICKET=$(echo "$BRANCH_NAME" | grep -Eo '[A-Z]+[-_][0-9]+' | head -n 1 || true)

# --- MODIFICHE FINISCONO QUI ---

cat > "$TEMP_PROMPT" <<EOF
Your primary task is to write a single-line git commit message in English.
Your main goal is to strictly follow the style, format, and conventions of the recent commits provided below.

Instructions:
- If a ticket ID is found in the branch name, prepend it to the message, matching the style of the recent commits.
- Use the imperative mood (e.g., "add" instead of "added").
- Keep the total message length under 72 characters.
- Do not include any explanations or quotation marks in the output.

Ticket ID extracted from branch: ${TICKET:-none}
Branch: "$BRANCH_NAME"
Recent commits:
$COMMIT_HISTORY

Files changed:
$FILES_CHANGED

Staged changes with surrounding code context:
$(cat "$TEMP_DIFF")

Write only the commit message:
EOF

PROMPT_CONTENT=$(cat "$TEMP_PROMPT")

JSON_PAYLOAD_FOR_API=$(jq -n --arg prompt_content "$PROMPT_CONTENT" \
'{
  "contents": [
    {
      "role": "user",
      "parts": [
        { "text": $prompt_content }
      ]
    }
  ],
  "generationConfig": {
    "temperature": 0.2,
    "topK": 40,
    "topP": 0.95
  }
}')

if [ -z "$JSON_PAYLOAD_FOR_API" ]; then
  echo "❌ Error: Failed to construct JSON payload with jq."
  exit 1
fi

ACCESS_TOKEN=$(gcloud auth print-access-token)
if [ -z "$ACCESS_TOKEN" ]; then
  echo "❌ Error: Failed to get gcloud access token. Make sure you are authenticated."
  exit 1
fi

if $DEBUG_MODE; then
  COUNT_TOKENS_API_URL="https://${GGIT_LOCATION}-aiplatform.googleapis.com/v1/projects/${GGIT_PROJECT}/locations/${GGIT_LOCATION}/publishers/google/models/${GGIT_MODEL_ID}:countTokens"
  
  # Usiamo lo stesso payload, ma l'API countTokens ignorerà generationConfig
  # Alcune API potrebbero richiedere un payload leggermente diverso per countTokens,
  # ma per Gemini su Vertex AI, il payload di generateContent è solitamente accettato.
  # Rimuoviamo generationConfig per essere più precisi se l'API lo preferisse
  JSON_PAYLOAD_FOR_COUNT_TOKENS=$(echo "$JSON_PAYLOAD_FOR_API" | jq 'del(.generationConfig)')


  TOKEN_COUNT_HTTP_STATUS=$(curl -s -X POST \
    -H "Authorization: Bearer ${ACCESS_TOKEN}" \
    -H "Content-Type: application/json" \
    "${COUNT_TOKENS_API_URL}" \
    -d "${JSON_PAYLOAD_FOR_COUNT_TOKENS}" \
    -o "${TEMP_API_RESPONSE_BODY}" \
    -w "%{http_code}")

  if [[ "$TOKEN_COUNT_HTTP_STATUS" -eq 200 ]]; then
    TOKEN_COUNT=$(jq -r '.totalTokens // "N/A"' "$TEMP_API_RESPONSE_BODY")
    echo "🔍 --- DEBUG: Prompt Token Count: ${TOKEN_COUNT} ---"
  else
    echo "🔍 --- DEBUG: Failed to count tokens. HTTP Status: ${TOKEN_COUNT_HTTP_STATUS} ---"
    if [[ -s "$TEMP_API_RESPONSE_BODY" ]]; then
        echo "🔍 --- DEBUG: Token count API response: ---"
        cat "$TEMP_API_RESPONSE_BODY"
        echo "🔍 --- END DEBUG ---"
    fi
  fi
fi

API_ENDPOINT_URL="https://${GGIT_LOCATION}-aiplatform.googleapis.com/v1/projects/${GGIT_PROJECT}/locations/${GGIT_LOCATION}/publishers/google/models/${GGIT_MODEL_ID}:generateContent"

HTTP_STATUS_CODE=$(curl -s -X POST \
  -H "Authorization: Bearer ${ACCESS_TOKEN}" \
  -H "Content-Type: application/json" \
  "${API_ENDPOINT_URL}" \
  -d "${JSON_PAYLOAD_FOR_API}" \
  -o "${TEMP_API_RESPONSE_BODY}" \
  -w "%{http_code}")

RESPONSE_BODY_CONTENT=$(cat "$TEMP_API_RESPONSE_BODY")

if [[ "$HTTP_STATUS_CODE" -ne 200 ]]; then
  echo "❌ Error: API request for commit message failed with HTTP status $HTTP_STATUS_CODE."
  echo "Response body:"
  echo "$RESPONSE_BODY_CONTENT"
  exit 1
fi

COMMIT_MSG=$(echo "$RESPONSE_BODY_CONTENT" | jq -r '.candidates[0].content.parts[0].text // empty' | tr -d '\r')

if [ -z "$COMMIT_MSG" ] || [ "$COMMIT_MSG" == "null" ] || [ "$COMMIT_MSG" == "" ]; then
  echo "❌ Error: Could not extract commit message from API response, or message is empty."
  echo "Response Body:"
  echo "$RESPONSE_BODY_CONTENT"
  exit 1
fi

COMMIT_MSG=$(echo "$COMMIT_MSG" | sed -e 's/^"//' -e 's/"$//' -e "s/^'//" -e "s/'$//")

echo ""
echo "✨ Generated commit message:"
echo ""
echo "$COMMIT_MSG"
echo ""
read -r -p "Use this commit message? [Y/n]: " CONFIRM

CONFIRM=${CONFIRM:-Y}
if [[ "$CONFIRM" =~ ^[Yy]$ ]]; then
  git commit -m "$COMMIT_MSG" "${FORWARD_ARGS[@]:+${FORWARD_ARGS[@]}}"
  echo "✅ Commit successful."
else
  echo "❌ Commit aborted by user."
fi

exit 0