#!/usr/bin/env bash
set -euo pipefail

GGIT_PROJECT="${GGIT_PROJECT:-}"
GGIT_LOCATION="${GGIT_LOCATION:-europe-west8}"
GGIT_MODEL_ID="${GGIT_MODEL_ID:-gemini-2.0-flash-001}"

if [ -z "$GGIT_PROJECT" ]; then
  echo "âŒ Error: GGIT_PROJECT environment variable is not set."
  echo "   Please set it to your Google Cloud Project ID."
  echo "   Example: export GGIT_PROJECT=\"your-gcp-project\""
  exit 1
fi

TEMP_DIFF=$(mktemp)
TEMP_PROMPT=$(mktemp)
TEMP_API_RESPONSE_BODY=$(mktemp)

cleanup() {
  rm -f "$TEMP_DIFF" "$TEMP_PROMPT" "$TEMP_API_RESPONSE_BODY"
}
trap cleanup EXIT

DEBUG_MODE=false
FORWARD_ARGS=()
for arg in "$@"; do
  case "$arg" in
    --debug)
      DEBUG_MODE=true
      ;;
    *)
      FORWARD_ARGS+=("$arg")
      ;;
  esac
done

git diff --cached > "$TEMP_DIFF"
if [ ! -s "$TEMP_DIFF" ]; then
  echo "â„¹ï¸ No staged changes to commit."
  exit 0
fi

FILES_CHANGED=$(git diff --cached --name-only)

# --- MODIFICHE INIZIANO QUI ---

if git show-ref --quiet HEAD; then
  # Ci sono commit, HEAD Ã¨ valido
  BRANCH_NAME=$(git rev-parse --abbrev-ref HEAD)
  COMMIT_HISTORY=$(git log -n 3 --pretty=format:"%s")
else
  # Nessun commit ancora (es. primo commit del repo), HEAD Ã¨ "unborn"
  # git symbolic-ref --short HEAD ottiene il nome del ramo non ancora nato (es. main o master)
  # Aggiungiamo un fallback a "main" se symbolic-ref dovesse fallire per qualche motivo imprevisto.
  BRANCH_NAME=$(git symbolic-ref --short HEAD 2>/dev/null || echo "main")
  COMMIT_HISTORY="(no previous commits)"
fi

TICKET=$(echo "$BRANCH_NAME" | grep -Eo '[A-Z]+[-_][0-9]+' | head -n 1 || true)

# --- MODIFICHE FINISCONO QUI ---


cat > "$TEMP_PROMPT" <<EOF
You are an assistant that writes atomic, concise, and properly formatted git commit messages in English. 

be concise and generate a single line commit message.

Instructions:
- Use a standard commit format like RINT-2535 feat: improve finital codec and improve testing, fix generic tests
- If a ticket ID is provided (e.g., ABC-1234), prepend it to the message
- Ticket ID extracted from branch: ${TICKET:-none}
- Keep the message under 72 characters
- Use imperative form (e.g., "add", not "added")
- Reference file names if relevant (e.g., "update AuthGuard in auth.ts")
- Avoid quotation marks and explanations

Branch: "$BRANCH_NAME"
Recent commits:
$COMMIT_HISTORY

Files changed:
$FILES_CHANGED

Staged changes with surrounding code context:
$(cat "$TEMP_DIFF")

Write only the commit message:
EOF

PROMPT_CONTENT=$(cat "$TEMP_PROMPT")

JSON_PAYLOAD_FOR_API=$(jq -n --arg prompt_content "$PROMPT_CONTENT" \
'{
  "contents": [
    {
      "role": "user",
      "parts": [
        { "text": $prompt_content }
      ]
    }
  ],
  "generationConfig": {
    "temperature": 0.1,
    "maxOutputTokens": 128,
    "topK": 40,
    "topP": 0.95
  }
}')

if [ -z "$JSON_PAYLOAD_FOR_API" ]; then
  echo "âŒ Error: Failed to construct JSON payload with jq."
  exit 1
fi

ACCESS_TOKEN=$(gcloud auth print-access-token)
if [ -z "$ACCESS_TOKEN" ]; then
  echo "âŒ Error: Failed to get gcloud access token. Make sure you are authenticated."
  exit 1
fi

if $DEBUG_MODE; then
  COUNT_TOKENS_API_URL="https://${GGIT_LOCATION}-aiplatform.googleapis.com/v1/projects/${GGIT_PROJECT}/locations/${GGIT_LOCATION}/publishers/google/models/${GGIT_MODEL_ID}:countTokens"
  
  # Usiamo lo stesso payload, ma l'API countTokens ignorerÃ  generationConfig
  # Alcune API potrebbero richiedere un payload leggermente diverso per countTokens,
  # ma per Gemini su Vertex AI, il payload di generateContent Ã¨ solitamente accettato.
  # Rimuoviamo generationConfig per essere piÃ¹ precisi se l'API lo preferisse
  JSON_PAYLOAD_FOR_COUNT_TOKENS=$(echo "$JSON_PAYLOAD_FOR_API" | jq 'del(.generationConfig)')


  TOKEN_COUNT_HTTP_STATUS=$(curl -s -X POST \
    -H "Authorization: Bearer ${ACCESS_TOKEN}" \
    -H "Content-Type: application/json" \
    "${COUNT_TOKENS_API_URL}" \
    -d "${JSON_PAYLOAD_FOR_COUNT_TOKENS}" \
    -o "${TEMP_API_RESPONSE_BODY}" \
    -w "%{http_code}")

  if [[ "$TOKEN_COUNT_HTTP_STATUS" -eq 200 ]]; then
    TOKEN_COUNT=$(jq -r '.totalTokens // "N/A"' "$TEMP_API_RESPONSE_BODY")
    echo "ðŸ” --- DEBUG: Prompt Token Count: ${TOKEN_COUNT} ---"
  else
    echo "ðŸ” --- DEBUG: Failed to count tokens. HTTP Status: ${TOKEN_COUNT_HTTP_STATUS} ---"
    if [[ -s "$TEMP_API_RESPONSE_BODY" ]]; then
        echo "ðŸ” --- DEBUG: Token count API response: ---"
        cat "$TEMP_API_RESPONSE_BODY"
        echo "ðŸ” --- END DEBUG ---"
    fi
  fi
fi

API_ENDPOINT_URL="https://${GGIT_LOCATION}-aiplatform.googleapis.com/v1/projects/${GGIT_PROJECT}/locations/${GGIT_LOCATION}/publishers/google/models/${GGIT_MODEL_ID}:generateContent"

HTTP_STATUS_CODE=$(curl -s -X POST \
  -H "Authorization: Bearer ${ACCESS_TOKEN}" \
  -H "Content-Type: application/json" \
  "${API_ENDPOINT_URL}" \
  -d "${JSON_PAYLOAD_FOR_API}" \
  -o "${TEMP_API_RESPONSE_BODY}" \
  -w "%{http_code}")

RESPONSE_BODY_CONTENT=$(cat "$TEMP_API_RESPONSE_BODY")

if [[ "$HTTP_STATUS_CODE" -ne 200 ]]; then
  echo "âŒ Error: API request for commit message failed with HTTP status $HTTP_STATUS_CODE."
  echo "Response body:"
  echo "$RESPONSE_BODY_CONTENT"
  exit 1
fi

COMMIT_MSG=$(echo "$RESPONSE_BODY_CONTENT" | jq -r '.candidates[0].content.parts[0].text // empty' | tr -d '\r')

if [ -z "$COMMIT_MSG" ] || [ "$COMMIT_MSG" == "null" ] || [ "$COMMIT_MSG" == "" ]; then
  echo "âŒ Error: Could not extract commit message from API response, or message is empty."
  echo "Response Body:"
  echo "$RESPONSE_BODY_CONTENT"
  exit 1
fi

COMMIT_MSG=$(echo "$COMMIT_MSG" | sed -e 's/^"//' -e 's/"$//' -e "s/^'//" -e "s/'$//")

echo ""
echo "âœ¨ Generated commit message:"
echo ""
echo "$COMMIT_MSG"
echo ""
read -r -p "Use this commit message? [Y/n]: " CONFIRM

CONFIRM=${CONFIRM:-Y}
if [[ "$CONFIRM" =~ ^[Yy]$ ]]; then
  git commit -m "$COMMIT_MSG" "${FORWARD_ARGS[@]}"
  echo "âœ… Commit successful."
else
  echo "âŒ Commit aborted by user."
fi

exit 0